package chapter2_Operator;

public class OperatorEx07 {

	public static void main(String[] args) {
		//비트 연산자 
		
		int num1 = 5;  		 	int num2 = 3;
	//128 64 32 16 8 4 2 1		128 64 32 16 8 4 2 1
	//  0  0  0  0 0 1 0 1        0  0  0  0 0 0 1 1
		int result;
		System.out.println(num1 & num2);
		//	0 0 0 0 0 1 0 1
		//  0 0 0 0 0 0 1 1
		//  0 0 0 0 0 0 0 1 비트단위 AND연산자는 둘다 1일 때 1을 반환한다  따라서 1비트의 자리에 둘다 1이 존재하므로  값으론 1이 나오게 됩니다.
		
		System.out.println(num1 | num2);
		//  0 0 0 0 0 1 1 1 비트단위 OR연산자는 둘중 하나라도 1이면 1을 반환하게 된다 따라서 4 2 1 의 자리에 1이존재하므로 결과값은 7이 되게된다.
		
		System.out.println(num1 ^ num2);
		//  0 0 0 0 0 1 1 0 비트단위 배타적OR(XOR)연산자는 둘중 한개만 1일때 1을 반환한다 따라서 4 2 의 자리에 1이 존재하게 되며 값은 6이 된다.
		
		System.out.println(~num1);
		//  1 1 1 1 1 0 1 0 비트단위 NOT연산자로서 0일때 1을, 1일때 0을 반환한다
		//따라서 128 64 32 16 8 2 의 자리에 1이 존재하게 되며 결과값은 250이지만 
		// 왜인지 모르게 값은 -6으로 표시되며 
		//-6 -5 -4 -3 -2 -1 || 0 1 2 3 4 5  양수를 음수로 바꾼뒤 -1을 한값이 나온다 이부분은 추후 공부를 통해 더알아봐야 될 것같다.
		// 비트전환 연산자 '~'에 의해 비트가 전환되고 나면 부호있는 타입의 피연산자는 부호가 반대로 변경된다고 한다 .
		//즉 피연산자의 1의 보수를 얻을수 잇는것이다. 그래서 비트전환연산자를 '1의 보수' 연산자라고도 한다 
		
		
	}

}
